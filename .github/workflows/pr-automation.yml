name: PR Automation

on:
  pull_request:
    types: [opened, edited, synchronize, ready_for_review]
  pull_request_review:
    types: [submitted]

permissions:
  pull-requests: write
  contents: read
  checks: read

jobs:
  pr-analysis:
    name: PR Analysis & Labeling
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze PR size and complexity
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const labels = [];
            
            // Get PR files and changes
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });
            
            const totalChanges = files.data.reduce((sum, file) => sum + file.changes, 0);
            const fileCount = files.data.length;
            
            // Size labeling
            if (totalChanges < 50) {
              labels.push('size:small');
            } else if (totalChanges < 200) {
              labels.push('size:medium');
            } else if (totalChanges < 500) {
              labels.push('size:large');
            } else {
              labels.push('size:extra-large');
            }
            
            // Component labeling based on files changed
            const changedFiles = files.data.map(f => f.filename);
            
            if (changedFiles.some(f => f.startsWith('src/'))) {
              labels.push('component:backend');
            }
            if (changedFiles.some(f => f.startsWith('frontend/'))) {
              labels.push('component:frontend');
            }
            if (changedFiles.some(f => f.includes('test'))) {
              labels.push('component:tests');
            }
            if (changedFiles.some(f => f.startsWith('.github/workflows'))) {
              labels.push('component:ci-cd');
            }
            if (changedFiles.some(f => f.includes('doc') || f.includes('README'))) {
              labels.push('component:documentation');
            }
            
            // Type labeling based on branch name and title
            const branchName = pr.head.ref.toLowerCase();
            const title = pr.title.toLowerCase();
            
            if (branchName.includes('feat') || title.includes('feat')) {
              labels.push('type:feature');
            } else if (branchName.includes('fix') || title.includes('fix')) {
              labels.push('type:bugfix');
            } else if (branchName.includes('refactor') || title.includes('refactor')) {
              labels.push('type:refactor');
            } else if (branchName.includes('chore') || title.includes('chore')) {
              labels.push('type:chore');
            }
            
            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: labels
              });
            }
            
            // Add size warning for large PRs
            if (totalChanges > 500) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `‚ö†Ô∏è **Large PR Warning**
                
              This PR contains ${totalChanges} changes across ${fileCount} files. Consider breaking it down into smaller, more focused PRs for easier review.

              **Tips for better PRs:**
              - Keep PRs focused on a single feature or fix
              - Aim for less than 200 lines of changes when possible
              - Split refactoring from feature work
              - Add clear descriptions and test cases`
              });
            }

  auto-merge-dependabot:
    name: Auto-merge Dependabot PRs
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    
    steps:
      - name: Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: "${{ secrets.GITHUB_TOKEN }}"

      - name: Auto-approve and merge minor updates
        if: steps.metadata.outputs.update-type == 'version-update:semver-patch' || steps.metadata.outputs.update-type == 'version-update:semver-minor'
        run: |
          gh pr review --approve "$PR_URL"
          gh pr merge --auto --merge "$PR_URL"
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}

  pr-quality-gate:
    name: PR Quality Gate
    runs-on: ubuntu-latest
    
    steps:
      - name: Check PR requirements
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const checks = [];
            
            // Check PR title format
            const titlePattern = /^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: .+/;
            if (!titlePattern.test(pr.title)) {
              checks.push('‚ùå PR title should follow conventional commit format: `type(scope): description`');
            } else {
              checks.push('‚úÖ PR title follows conventional commit format');
            }
            
            // Check PR description
            if (!pr.body || pr.body.length < 50) {
              checks.push('‚ùå PR description should be at least 50 characters');
            } else {
              checks.push('‚úÖ PR has adequate description');
            }
            
            // Check if PR is not a draft
            if (pr.draft) {
              checks.push('‚è≥ PR is in draft mode');
            } else {
              checks.push('‚úÖ PR is ready for review');
            }
            
            // Post quality gate results
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: `## PR Quality Gate Results\n\n${checks.join('\n')}\n\n${checks.some(c => c.includes('‚ùå')) ? '‚ö†Ô∏è Please address the issues above before requesting review.' : 'üéâ All quality checks passed!'}`
            });
